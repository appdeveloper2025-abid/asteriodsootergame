<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ABID's Asteroid Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Import a retro-style font */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
        
        :root {
            --game-color: #00ff00; /* Bright Neon Green */
            --bg-color: #00001a; /* Very Dark Space Blue */
            --shield-color: #00bfff; /* Neon Blue for Shield */
            --thrust-color: #ffaa00; /* Orange for Thrust */
            --bomb-color: #ff00ff; /* Magenta for Bomb */
        }

        body {
            font-family: 'Space Mono', monospace;
            background-color: #000;
            color: var(--game-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 8px;
            box-sizing: border-box;
        }

        #game-container {
            width: 100%;
            max-width: 900px; 
            height: auto;
            display: flex;
            flex-direction: column;
            border: 4px solid var(--game-color);
            box-shadow: 0 0 25px var(--game-color);
            border-radius: 12px;
            overflow: hidden;
            background-color: var(--bg-color);
        }

        #gameCanvas {
            width: 100%;
            /* Set a fixed aspect ratio for the game area */
            aspect-ratio: 16 / 9;
            background-color: var(--bg-color);
            cursor: none; 
            touch-action: none; /* Prevent browser touch behavior on canvas */
        }

        .controls {
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            background-color: #000;
            border-top: 2px solid var(--game-color);
        }

        .control-button {
            flex-grow: 1;
            min-width: 80px;
            max-width: 120px;
            padding: 0.75rem 0.5rem;
            font-size: 1.5rem; /* Larger font for icons */
            font-weight: bold;
            color: #000;
            background-color: var(--game-color);
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 0 #005000; 
            transition: all 0.1s ease;
            cursor: pointer;
            line-height: 1; /* Adjust line height for icons */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Specific button adjustments for text content if needed, though icons handle this */
        #thrustBtn { font-size: 2rem; } /* Make the thrust arrow bigger */
        #bombBtn { font-size: 1.2rem; } /* Adjust bomb symbol size */


        .control-button:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 #005000;
        }

        /* Responsive adjustments for larger screens */
        @media (min-width: 640px) {
            .controls {
                gap: 1rem;
                padding: 1.5rem;
            }
            .control-button {
                min-width: 100px;
                max-width: 150px;
                font-size: 2rem; /* Even larger for desktop */
            }
            #bombBtn { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Mobile/Touch Controls --><div class="controls">
        <button id="thrustBtn" class="control-button">â–²</button>
        <button id="leftBtn" class="control-button">â—€</button>
        <button id="rightBtn" class="control-button">â–¶</button>
        <button id="fireBtn" class="control-button">âœ±</button>
        <button id="bombBtn" class="control-button">ðŸ’£</button>
    </div>
</div>

<script>
    // Global Constants
    const FPS = 60; 
    const SHIP_SIZE = 30; 
    const SHIP_THRUST = 0.08; 
    const SHIP_FRICTION = 0.99; 
    const SHIP_TURN_SPEED = 400; 
    const BULLET_SPEED = 7; 
    const BULLET_MAX = 15; 
    const ASTEROID_NUM = 4; 
    const ASTEROID_SPEED = 1.0; 
    const ASTEROID_SIZE = 100; 
    const GAME_LIVES = 4; 
    const INITIAL_BOMBS = 3;

    // New Weapon/Feature Constants
    const TRIPLE_SHOT_DURATION = FPS * 10; 
    const SHIELD_DURATION = FPS * 8; 
    const POWERUP_SPAWN_INTERVAL = FPS * 15; 

    // Canvas setup
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Game State Variables
    let ship;
    let asteroids = [];
    let bullets = [];
    let powerUps = [];
    let score = 0;
    let lives = GAME_LIVES;
    let bombs = INITIAL_BOMBS; // New: Bomb count
    let level = 0;
    let gameOver = true;
    let gameLoopInterval;
    let powerUpTimer = POWERUP_SPAWN_INTERVAL;

    // Input States
    let key = {
        ArrowUp: false,
        ArrowLeft: false,
        ArrowRight: false,
        Space: false,
        KeyB: false // For Bomb
    };

    // --- Utility Functions ---

    /** Helper to get CSS variable value */
    function var2val(varName) {
        return getComputedStyle(document.documentElement).getPropertyValue(varName);
    }

    /** Resets the canvas dimensions to fit the container/window. */
    function resizeCanvas() {
        const container = document.getElementById("game-container");
        canvas.width = container.clientWidth;
        canvas.height = canvas.width * (9 / 16); 
    }

    /** Generates a random polygon shape for an asteroid. */
    function createAsteroidShape(radius) {
        const vertices = Math.floor(Math.random() * 5 + 7); 
        const shape = [];
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const r = radius * (0.7 + Math.random() * 0.6); 
            shape.push([r * Math.cos(angle), r * Math.sin(angle)]);
        }
        return shape;
    }
    
    /** Gets a random integer between min (inclusive) and max (exclusive) */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }


    // --- Game Object Classes ---

    class Ship {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.r = SHIP_SIZE / 2;
            this.a = 90 / 180 * Math.PI; 
            this.v = { x: 0, y: 0 }; 
            this.thrusting = false;
            this.blinking = false; 
            this.blinkTime = 0;
            this.maxBlinkTime = 3; 
            this.dead = false;

            this.weaponType = 1; // 1: Normal, 2: Triple Shot
            this.weaponTimer = 0; 
            this.shieldTimer = 0; 
            this.fireCooldown = 0; 
        }

        isShieldActive() {
            return this.shieldTimer > 0;
        }

        draw() {
            if (this.blinking && Math.floor(this.blinkTime * FPS / (FPS * 0.1)) % 2 === 0) {
                if (!this.isShieldActive() || Math.floor(this.blinkTime * FPS / (FPS * 0.1)) % 4 !== 0) {
                     return;
                }
            }
            
            ctx.strokeStyle = var2val('--game-color');
            ctx.fillStyle = "rgba(0, 255, 0, 0.2)"; 
            ctx.lineWidth = 2;
            
            const tipX = this.x + this.r * Math.cos(this.a);
            const tipY = this.y - this.r * Math.sin(this.a);
            const sternX1 = this.x - this.r * (Math.cos(this.a) + Math.sin(this.a));
            const sternY1 = this.y + this.r * (Math.sin(this.a) - Math.cos(this.a));
            const sternX2 = this.x - this.r * (Math.cos(this.a) - Math.sin(this.a));
            const sternY2 = this.y + this.r * (Math.sin(this.a) + Math.cos(this.a));

            ctx.beginPath();
            ctx.moveTo(tipX, tipY);
            ctx.lineTo(sternX1, sternY1);
            ctx.lineTo(sternX2, sternY2);
            ctx.closePath();
            ctx.stroke();
            ctx.fill();

            // Draw Shield (if active)
            if (this.isShieldActive()) {
                const shieldColor = var2val('--shield-color');
                ctx.strokeStyle = shieldColor;
                ctx.fillStyle = shieldColor + "20"; 
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r * 1.5, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.stroke();
            }

            // Draw the engine thrust (if thrusting)
            if (this.thrusting) {
                const flameLength = this.r * 0.8 + Math.random() * this.r * 0.4;
                const flameTipX = this.x - (this.r * 1.5 + flameLength) * Math.cos(this.a);
                const flameTipY = this.y + (this.r * 1.5 + flameLength) * Math.sin(this.a);

                ctx.strokeStyle = var2val('--thrust-color'); 
                ctx.fillStyle = var2val('--thrust-color') + "AA"; 
                ctx.beginPath();
                ctx.moveTo(sternX1, sternY1);
                ctx.lineTo(flameTipX, flameTipY);
                ctx.lineTo(sternX2, sternY2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        update(dt) {
            // Handle Timers
            if (this.shieldTimer > 0) this.shieldTimer -= dt;
            if (this.weaponTimer > 0) this.weaponTimer -= dt;
            if (this.weaponTimer <= 0 && this.weaponType !== 1) {
                this.weaponType = 1;
                this.weaponTimer = 0;
            }
            if (this.fireCooldown > 0) this.fireCooldown -= dt;
            
            // Apply thrust
            if (this.thrusting) {
                this.v.x += SHIP_THRUST * Math.cos(this.a) * (dt * FPS);
                this.v.y -= SHIP_THRUST * Math.sin(this.a) * (dt * FPS);
            }

            // Apply friction
            this.v.x *= SHIP_FRICTION ** (dt * FPS);
            this.v.y *= SHIP_FRICTION ** (dt * FPS);

            // Rotate
            const turnRate = SHIP_TURN_SPEED / 180 * Math.PI / FPS;
            if (key.ArrowLeft) {
                this.a += turnRate * (dt * FPS);
            }
            if (key.ArrowRight) {
                this.a -= turnRate * (dt * FPS);
            }

            // Move
            this.x += this.v.x * (dt * FPS);
            this.y += this.v.y * (dt * FPS);

            // Handle screen wrapping
            if (this.x < 0 - this.r) this.x = canvas.width + this.r;
            if (this.x > canvas.width + this.r) this.x = 0 - this.r;
            if (this.y < 0 - this.r) this.y = canvas.height + this.r;
            if (this.y > canvas.height + this.r) this.y = 0 - this.r;

            // Handle blinking/invulnerability
            if (this.blinking) {
                this.blinkTime += dt;
                if (this.blinkTime >= this.maxBlinkTime) {
                    this.blinking = false;
                }
            }
        }

        respawn() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.v = { x: 0, y: 0 };
            this.a = 90 / 180 * Math.PI;
            this.blinking = true;
            this.blinkTime = 0;
            this.dead = false;
            this.weaponType = 1; 
            this.weaponTimer = 0;
            this.fireCooldown = 0;
            this.shieldTimer = 0; // Shield also removed on death
        }
        
        applyPowerUp(type) {
            if (type === 'TripleShot') {
                this.weaponType = 2;
                this.weaponTimer = TRIPLE_SHOT_DURATION / FPS; 
            } else if (type === 'Shield') {
                this.shieldTimer = SHIELD_DURATION / FPS; 
            } else if (type === 'Bomb') {
                bombs++;
            }
        }
    }

    class Asteroid {
        constructor(x, y, r, level) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.level = level;
            
            const speed = ASTEROID_SPEED * (1 + (level - 1) * 0.3) * (1 + level * 0.1); 
            const angle = Math.random() * Math.PI * 2;
            this.v = { x: speed * Math.cos(angle), y: speed * Math.sin(angle) };

            this.a = Math.random() * Math.PI * 2; 
            this.rotV = Math.random() * 0.05 * (Math.random() < 0.5 ? 1 : -1); 

            this.shape = createAsteroidShape(this.r);
        }

        draw() {
            ctx.strokeStyle = var2val('--game-color');
            ctx.fillStyle = "rgba(0, 255, 0, 0.05)";
            ctx.lineWidth = 1.5;

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.a);

            ctx.beginPath();
            ctx.moveTo(this.shape[0][0], this.shape[0][1]);
            for (let i = 1; i < this.shape.length; i++) {
                ctx.lineTo(this.shape[i][0], this.shape[i][1]);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();

            ctx.restore();
        }

        update(dt) {
            this.x += this.v.x * (dt * FPS);
            this.y += this.v.y * (dt * FPS);
            this.a += this.rotV * (dt * FPS);

            // Handle screen wrapping
            if (this.x < 0 - this.r) this.x = canvas.width + this.r;
            if (this.x > canvas.width + this.r) this.x = 0 - this.r;
            if (this.y < 0 - this.r) this.y = canvas.height + this.r;
            if (this.y > canvas.height + this.r) this.y = 0 - this.r;
        }

        split() {
            if (this.level > 1) {
                const newR = this.r * 0.6;
                const newLevel = this.level - 1;
                const newAsteroids = [];

                for (let i = 0; i < 2; i++) {
                    const newAngle = Math.random() * Math.PI * 2;
                    const speedMultiplier = 1.2 + Math.random() * 0.4; 
                    const speed = (Math.sqrt(this.v.x**2 + this.v.y**2) + 0.5) * speedMultiplier;
                    const newV = { x: speed * Math.cos(newAngle), y: speed * Math.sin(newAngle) };

                    const asteroid = new Asteroid(this.x, this.y, newR, newLevel);
                    asteroid.v = newV;
                    newAsteroids.push(asteroid);
                }
                return newAsteroids;
            }
            return [];
        }
    }

    class Bullet {
        constructor(angle) { 
            this.r = 2; 
            this.x = ship.x + ship.r * Math.cos(ship.a);
            this.y = ship.y - ship.r * Math.sin(ship.a);

            this.v = {
                x: BULLET_SPEED * Math.cos(angle) + ship.v.x * 0.2, 
                y: -(BULLET_SPEED * Math.sin(angle)) + ship.v.y * 0.2
            };
            this.lifetime = 0; 
            this.maxLifetime = FPS * 2; 
        }

        draw() {
            ctx.fillStyle = var2val('--game-color');
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);
            ctx.fill();
        }

        update(dt) {
            this.x += this.v.x * (dt * FPS);
            this.y += this.v.y * (dt * FPS);
            this.lifetime++;

            if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                 this.lifetime = this.maxLifetime; 
            }
        }
    }

    class PowerUp {
        /**
         * @param {string} type - 'TripleShot', 'Shield', or 'Bomb'
         */
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.r = 15;
            this.type = type;
            this.v = { x: Math.random() - 0.5, y: Math.random() - 0.5 }; 
            this.spin = Math.random() * 0.05 * (Math.random() < 0.5 ? 1 : -1);
            this.angle = 0;
            
            // Define colors and symbols based on type
            this.color = '';
            this.symbol = '';
            if (type === 'TripleShot') {
                this.color = '#ff33ff'; // Magenta
                this.symbol = 'T';
            } else if (type === 'Shield') {
                this.color = var2val('--shield-color'); // Blue
                this.symbol = 'S';
            } else if (type === 'Bomb') {
                this.color = var2val('--bomb-color'); // Magenta
                this.symbol = 'ðŸ’£'; // Emoji for bomb
            }
            this.lifetime = FPS * 12; 
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            // Outer Glow/Box
            ctx.fillStyle = this.color + "50";
            ctx.fillRect(-this.r, -this.r, this.r * 2, this.r * 2);

            // Inner Symbol
            ctx.fillStyle = this.color;
            ctx.font = "bold 20px 'Space Mono', monospace";
            if (this.type === 'Bomb') { // Emoji might need different font settings
                ctx.font = "30px sans-serif"; // Use system emoji font
            }
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.symbol, 0, 0);

            ctx.restore();
        }

        update(dt) {
            this.x += this.v.x * (dt * FPS) * 0.5;
            this.y += this.v.y * (dt * FPS) * 0.5;
            this.angle += this.spin * (dt * FPS);
            this.lifetime -= 1;
            
            // Screen wrapping for power-ups
            if (this.x < 0 - this.r) this.x = canvas.width + this.r;
            if (this.x > canvas.width + this.r) this.x = 0 - this.r;
            if (this.y < 0 - this.r) this.y = canvas.height + this.r;
            if (this.y > canvas.height + this.r) this.y = 0 - this.r;
        }
    }

    // --- Game Logic Functions ---

    function initGame() {
        resizeCanvas();
        ship = new Ship();
        level = 0;
        score = 0;
        lives = GAME_LIVES;
        bombs = INITIAL_BOMBS; // Reset bombs
        powerUps = [];
        powerUpTimer = POWERUP_SPAWN_INTERVAL;
        
        startLevel(ASTEROID_NUM);
        
        gameOver = false;
        if (!gameLoopInterval) {
            gameLoopInterval = setInterval(gameLoop, 1000 / FPS);
        }
    }

    function startLevel(numAsteroids) {
        asteroids = [];
        bullets = [];
        level++;

        const minDistance = canvas.width * 0.3;

        for (let i = 0; i < numAsteroids; i++) {
            let x, y;
            let distance;
            const size = ASTEROID_SIZE;
            const levelSize = 3;

            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
                distance = Math.sqrt((x - canvas.width / 2)**2 + (y - canvas.height / 2)**2);
            } while (distance < minDistance);
            
            asteroids.push(new Asteroid(x, y, size, levelSize));
        }
        ship.respawn();
    }

    function shootBullet() {
        if (ship.dead || ship.fireCooldown > 0) return;
        
        let shotsFired = 0;
        
        if (ship.weaponType === 1) { // Normal Shot
            if (bullets.length < BULLET_MAX) {
                bullets.push(new Bullet(ship.a));
                shotsFired = 1;
            }
        } else if (ship.weaponType === 2) { // Triple Shot
             if (bullets.length < BULLET_MAX - 2) { 
                const spread = 15 / 180 * Math.PI; 
                
                bullets.push(new Bullet(ship.a)); 
                bullets.push(new Bullet(ship.a + spread));
                bullets.push(new Bullet(ship.a - spread));
                shotsFired = 3;
            }
        }

        if (shotsFired > 0) {
            ship.fireCooldown = 1 / 15; // 15 shots per second max
        }
    }
    
    function useBomb() {
        if (ship.dead || bombs <= 0) return;

        bombs--;
        score += asteroids.length * 100; // Bonus points for all destroyed asteroids
        asteroids = []; // Clear all asteroids

        // Trigger the next level if all asteroids are cleared
        startLevel(ASTEROID_NUM + level * 0.5); 
    }


    function spawnPowerUp(x, y) {
        // Randomly choose between Triple Shot, Shield, and Bomb
        const types = ['TripleShot', 'Shield', 'Bomb'];
        const type = types[getRandomInt(0, types.length)];
        powerUps.push(new PowerUp(x, y, type));
    }

    function drawScore() {
        ctx.font = "24px 'Space Mono', monospace";
        ctx.fillStyle = var2val('--game-color');
        ctx.textAlign = "left";
        ctx.fillText(`SCORE: ${score}`, 20, 35);
        ctx.fillText(`LEVEL: ${level}`, 20, 65);
    }
    
    function drawPowerUpStatus() {
        ctx.font = "18px 'Space Mono', monospace";
        ctx.textAlign = "right";
        ctx.textBaseline = "top";
        const x = canvas.width - 20;
        let y = 10;
        
        if (ship.isShieldActive()) {
            const time = Math.ceil(ship.shieldTimer);
            ctx.fillStyle = var2val('--shield-color');
            ctx.fillText(`SHIELD: ${time}s`, x, y);
            y += 25;
        }

        if (ship.weaponType === 2) {
            const time = Math.ceil(ship.weaponTimer);
            ctx.fillStyle = '#ff33ff';
            ctx.fillText(`TRIPLE SHOT: ${time}s`, x, y);
            y += 25;
        }

        // Draw bomb count
        ctx.fillStyle = var2val('--bomb-color');
        ctx.fillText(`BOMBS: ${bombs}`, x, y);
    }

    function drawLives() {
        const offset = 8;
        const size = SHIP_SIZE / 2; // Smaller icons for lives display
        const baseX = 20; // Left-aligned
        const baseY = canvas.height - 35; // Bottom-left
        const iconPadding = 5;

        ctx.font = "20px 'Space Mono', monospace";
        ctx.fillStyle = var2val('--game-color');
        ctx.textAlign = "left";
        ctx.fillText("LIVES:", baseX, baseY + 5);

        for (let i = 0; i < lives; i++) {
            ctx.strokeStyle = var2val('--game-color');
            ctx.lineWidth = 1.5;

            ctx.save();
            ctx.translate(baseX + 60 + i * (size * 1.5 + offset), baseY);
            ctx.rotate(90 / 180 * Math.PI); // Always pointing up
            
            ctx.beginPath();
            ctx.moveTo(size * 0.5, 0);
            ctx.lineTo(-size * 0.5, size * 0.5); 
            ctx.lineTo(-size * 0.5, -size * 0.5);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }
    }

    function drawMessage(text, isMainTitle = false) {
        ctx.font = "bold 56px 'Space Mono', monospace";
        ctx.fillStyle = var2val('--game-color');
        ctx.textAlign = "center";
        
        if (isMainTitle) {
            ctx.fillText("ABID's ASTEROID SHOOTER", canvas.width / 2, canvas.height / 2 - 60);
            ctx.font = "24px 'Space Mono', monospace";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText("Press FIRE (âœ±) or SPACE to Start", canvas.width / 2, canvas.height / 2 + 70);

        } else {
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 30);
            ctx.font = "24px 'Space Mono', monospace";
            ctx.fillText("Press FIRE (âœ±) or SPACE to Restart", canvas.width / 2, canvas.height / 2 + 30);
        }
    }

    function update() {
        const dt = 1 / FPS; 

        // Check for new level
        if (asteroids.length === 0) {
            startLevel(ASTEROID_NUM + level * 0.5); 
        }
        
        // --- Power-up Spawning ---
        powerUpTimer -= 1;
        if (powerUpTimer <= 0) {
            spawnPowerUp(getRandomInt(canvas.width * 0.2, canvas.width * 0.8), 
                         getRandomInt(canvas.height * 0.2, canvas.height * 0.8));
            powerUpTimer = POWERUP_SPPAWN_INTERVAL;
        }

        // Update Ship
        ship.thrusting = key.ArrowUp;
        ship.update(dt);

        // Update Asteroids
        asteroids.forEach(a => a.update(dt));

        // Update Bullets
        bullets = bullets.filter(b => b.lifetime < b.maxLifetime);
        bullets.forEach(b => b.update(dt));
        
        // Update PowerUps
        powerUps = powerUps.filter(p => p.lifetime > 0);
        powerUps.forEach(p => p.update(dt));

        // --- Collision Detection ---

        // 1. Bullet to Asteroid
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            let hit = false;
            for (let j = asteroids.length - 1; j >= 0; j--) {
                const asteroid = asteroids[j];

                const distSq = (bullet.x - asteroid.x)**2 + (bullet.y - asteroid.y)**2;
                if (distSq < (asteroid.r + bullet.r)**2) {
                    hit = true;
                    bullets.splice(i, 1);
                    
                    score += 20 * asteroid.level;

                    if (asteroid.level >= 2 && Math.random() < 0.05) {
                        spawnPowerUp(asteroid.x, asteroid.y);
                    }

                    // Split asteroid
                    const newAsteroids = asteroid.split();
                    asteroids.splice(j, 1);
                    asteroids.push(...newAsteroids);
                    break;
                }
            }
        }
        
        // 2. Ship to Asteroid
        if (!ship.blinking && !ship.dead) {
            for (let j = asteroids.length - 1; j >= 0; j--) {
                const asteroid = asteroids[j];
                const distSq = (ship.x - asteroid.x)**2 + (ship.y - asteroid.y)**2;

                if (distSq < (ship.r + asteroid.r) * 0.8) { 
                    if (ship.isShieldActive()) {
                        ship.shieldTimer = 0; 
                        score += 10 * asteroid.level; 
                    } else {
                        lives--;
                        if (lives <= 0) {
                            gameOver = true;
                            ship.dead = true;
                        } else {
                            ship.respawn();
                        }
                    }

                    const newAsteroids = asteroid.split();
                    asteroids.splice(j, 1);
                    asteroids.push(...newAsteroids);
                    break;
                }
            }
        }
        
        // 3. Ship to PowerUp
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];
            const distSq = (ship.x - powerUp.x)**2 + (ship.y - powerUp.y)**2;

            if (distSq < (ship.r + powerUp.r)**2) {
                ship.applyPowerUp(powerUp.type);
                powerUps.splice(i, 1); 
                break;
            }
        }
    }

    function draw() {
        ctx.fillStyle = var2val('--bg-color');
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        powerUps.forEach(p => p.draw());
        ship.draw();
        bullets.forEach(b => b.draw());
        asteroids.forEach(a => a.draw());

        drawScore();
        drawLives();
        drawPowerUpStatus();
    }

    function gameLoop() {
        if (!gameOver) {
            update();
            draw();
        } else {
            draw(); 
            if (level === 0) {
                drawMessage("Welcome to your mission!", true);
            } else {
                drawMessage("GAME OVER");
            }
            
            if (key.Space) {
                initGame();
                key.Space = false; 
            }
        }
    }

    // --- Event Handlers ---

    // Keyboard Input (for desktop)
    document.addEventListener("keydown", (e) => {
        if (gameOver && (e.code === "Space" || e.code === "Enter")) {
            key.Space = true; 
            return;
        } else if (gameOver) {
             return;
        }

        switch (e.code) {
            case "ArrowUp":
                key.ArrowUp = true;
                break;
            case "ArrowLeft":
                key.ArrowLeft = true;
                break;
            case "ArrowRight":
                key.ArrowRight = true;
                break;
            case "Space":
            case "Enter": // Added Enter as an alternative fire key
                e.preventDefault(); 
                shootBullet();
                break;
            case "KeyB": // 'B' key for Bomb
                useBomb();
                break;
        }
    });

    document.addEventListener("keyup", (e) => {
        switch (e.code) {
            case "ArrowUp":
                key.ArrowUp = false;
                break;
            case "ArrowLeft":
                key.ArrowLeft = false;
                break;
            case "ArrowRight":
                key.ArrowRight = false;
                break;
            case "Space":
            case "Enter":
                if (gameOver) key.Space = false; 
                break;
            case "KeyB":
                // No continuous action for bomb, so just release
                break;
        }
    });

    // Mobile/Touch Input
    const touchControls = {
        'thrustBtn': 'ArrowUp',
        'leftBtn': 'ArrowLeft',
        'rightBtn': 'ArrowRight',
        'fireBtn': 'Space',
        'bombBtn': 'KeyB' // New bomb button
    };

    Object.keys(touchControls).forEach(id => {
        const btn = document.getElementById(id);
        const code = touchControls[id];

        const activate = (e) => {
            e.preventDefault();
            if (code === 'Space') {
                if (gameOver) {
                    key.Space = true; 
                } else {
                    shootBullet(); 
                }
            } else if (code === 'KeyB') {
                useBomb(); // Bomb activates on touch/click
            }
            else {
                key[code] = true;
            }
        };

        const deactivate = (e) => {
            e.preventDefault();
            if (code === 'Space' && gameOver) {
                key.Space = false; 
            } else if (code !== 'Space' && code !== 'KeyB' && !gameOver) { // Bomb is a single-press, not hold
                key[code] = false;
            }
        };

        btn.addEventListener('touchstart', activate);
        btn.addEventListener('touchend', deactivate);
        btn.addEventListener('touchcancel', deactivate);
        
        btn.addEventListener('mousedown', activate);
        btn.addEventListener('mouseup', deactivate);
    });
    
    // Window Resize Handler
    window.addEventListener('resize', () => {
        resizeCanvas();
        if (ship) {
            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
        }
    });


    // Start the game loop on window load
    window.onload = function () {
        initGame();
        level = 0; 
        gameOver = true;
        drawMessage("Welcome to your mission!", true);
    }

</script>
</body>
</html>

